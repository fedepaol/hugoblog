<!DOCTYPE html>
<html lang="en-us">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="public" />
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.54.0" />

    
    
    

<title>an optimization story â€¢ My little software warehouse</title>


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="an optimization story"/>
<meta name="twitter:description" content="There are some scenarios where the order matters Let&rsquo;s say that you have an api that can receive &ldquo;actions&rdquo; to be performed on a given endpoint.
Think about you buying something on Amazon and then changing your mind and revoking your order. You don&rsquo;t want those two actions to be swapped, otherwise the cancellation will be refused (the order you want to cancel do not exists yet) and then the item you don&rsquo;t want anymore will be ordered (since the action of ordering the item receives the backend after the cancelation)."/>

<meta property="og:title" content="an optimization story" />
<meta property="og:description" content="There are some scenarios where the order matters Let&rsquo;s say that you have an api that can receive &ldquo;actions&rdquo; to be performed on a given endpoint.
Think about you buying something on Amazon and then changing your mind and revoking your order. You don&rsquo;t want those two actions to be swapped, otherwise the cancellation will be refused (the order you want to cancel do not exists yet) and then the item you don&rsquo;t want anymore will be ordered (since the action of ordering the item receives the backend after the cancelation)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://fedepaol.github.io/fava/2019/02/13/an-optimization-story/" />
<meta property="article:published_time" content="2019-02-13T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2019-02-13T00:00:00&#43;00:00"/>


    






<link rel="stylesheet" href="/scss/hyde-hyde.6a83d62c39a364f036df4db1ecd564645635d6c7fc182425cb501218fec485f5.css" integrity="sha256-aoPWLDmjZPA2302x7NVkZFY11sf8GCQly1ASGP7EhfU=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    

</head>


    <body class=" ">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="http://fedepaol.github.io/">My little software warehouse</a>
      </span>
      
      
      <p class="site__description">
        
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">My little software warehouse</label>
      <div class="menu-content">
        <div>
	<ul class="sidebar-nav">
		 
		
		</li>
	</ul>
</div>

        <section class="social">
	
	
	
	
	
	
	
	
	
	
	
	
	
	
</section>

      </div>
    </div>
    


  </div>
</div>

        <div class="content container">
            
    <article>
  <header>
    <h1>an optimization story</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Feb 13, 2019
    
    
    
    
    
    <br/>
    <i class="fas fa-clock"></i> 3 min read
</div>


  </header>
  
  
  <div class="post">
    

<h2 id="there-are-some-scenarios-where-the-order-matters">There are some scenarios where the order matters</h2>

<p>Let&rsquo;s say that you have an api that can receive &ldquo;actions&rdquo; to be performed on a given endpoint.</p>

<p>Think about you buying something on Amazon and then changing your mind and revoking your order. You don&rsquo;t want those two actions to be swapped, otherwise the cancellation will be refused (the order you want to cancel do not exists yet) and then the item you don&rsquo;t want anymore will be ordered (since the action of ordering the item receives the backend <strong>after</strong> the cancelation).</p>

<p>Also, in this (not so) hypothetic scenario, processing each message has a cost. For example, the message needs to be validated against some external endpoint, or it needs to be enriched with data that can be found on a database.</p>

<p>So here we have a dilemma: we would like to take advantage of go concurrency system and increase the throughput by processing the messages concurrently, but at the same time the order matters and you can&rsquo;t just pass the events to the goroutines because the order the messages are received won&rsquo;t be respected.</p>

<p>Processing the messages in a concurrent fashion would amortise the processing cost of each message. By processing the messages sequentially, a queued message will have to wait all the messages received before.</p>

<h2 id="so-my-question-is-can-we-have-the-best-of-both-worlds">So my question is, can we have the best of both worlds?</h2>

<p>All this to say that I wanted to write a simple example that reorders the messages as soon as they are processed concurrently.</p>

<p>The basic idea is to mark each message with a sequence number, handle many messages concurrently, and pass the results to another goroutine that will then reorder the.</p>

<p>The architecture is something like this:</p>

<p>{% img /images/optimization/fast.png 450 %}</p>

<p>I tried to simulate the <em>time consuming operation</em> with a random interval between 1 - 100 milliseconds:</p>

<pre><code class="language-go">    howLong := rand.Intn(100)
    time.Sleep(time.Duration(howLong) * time.Millisecond)
</code></pre>

<p>The <em>consuming</em> part only involves printing the result of the <em>computation</em> on the standard output, in order to be able to check if the re-ordering was done properly.</p>

<h3 id="channels-and-goroutines">Channels and goroutines</h3>

<p>The moving parts are:</p>

<ul>
<li>a <a href="https://github.com/fedepaol/goconcurrencylab/blob/master/fast/main.go#L67"><strong>producer</strong> goroutine</a> that writes on a source channel</li>
<li>many <a href="https://github.com/fedepaol/goconcurrencylab/blob/master/fast/main.go#L100"><strong>worker</strong> goroutines</a> that process the messages sent on the source channel &amp; write on the same output channel</li>
<li>a <a href="https://github.com/fedepaol/goconcurrencylab/blob/master/fast/main.go#L48"><strong>result processor</strong> goroutine</a> that reads the results from the output channel, try to reorder them and then print the output</li>
</ul>

<h2 id="first-take-away-lesson">First take away lesson</h2>

<p>This working example demonstrate how the communicating paradigm makes it easy to handle and manipulate events concurrently with Go. The fact that we do have requirements of sequentiality does not mean that we can&rsquo;t try to take advantage of the multiprocessing powers of Go.</p>

<h3 id="further-optimizations">Further optimizations</h3>

<p>During the first implementation, I kept the &ldquo;reordering part&rdquo; as simple as I could, meaning that the events are just appended to a slice, then the result processor keeps a &ldquo;last processed&rdquo; sequence number and tries to retrieve the next event to be emitted.</p>

<p>The code for the &ldquo;draining part&rdquo; is:</p>

<pre><code class="language-go">    func drainParked(parked *[]result, next *int) {
    	for {
    		var found bool
    		for i, val := range *parked {
    			if val.seqNum == *next {
    				fmt.Printf(&quot;Processed %d\n&quot;, val.seqNum)
    				*next++
    				*parked = append((*parked)[:i], (*parked)[i+1:]...)
    				found = true
    				break
    			}
    		}
    		if !found {
    			return
    		}
    	}
}
</code></pre>

<p>I wrote the code in the first way it came to my mind, thinking that I could leverage the profiling tools provided by Go in order to see how to optimize it.</p>

  </div>
  

<div class="navigation navigation-single">
    
    <a href="/fava/2018/12/11/fast-messaging-with-nats-and-go-part-2/" class="navigation-prev">
      <i aria-hidden="true" class="fa fa-chevron-left"></i>
      <span class="navigation-tittle">fast messaging with nats and go part 2</span>
    </a>
    
    
</div>


  

  
    


</article>


        </div>
        
    
<script defer src="https://use.fontawesome.com/releases/v5.5.0/js/all.js" integrity="sha384-GqVMZRt5Gn7tB9D9q7ONtcp4gtHIUEW/yG7h98J7IpE3kpi+srfFyyB/04OV6pG0" crossorigin="anonymous"></script>


    
    
    <script type="text/javascript">
        
        hljs.initHighlightingOnLoad();
    </script>
    




    



    </body>
</html>
