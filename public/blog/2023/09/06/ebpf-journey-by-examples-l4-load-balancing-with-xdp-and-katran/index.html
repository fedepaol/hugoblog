<!DOCTYPE html>
<html lang="en">

<head>
  <title>
  eBPF journey by examples: L4 load balancing with XDP and Katran · My little software warehouse
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Federico Paolinelli">
<meta name="description" content="Explore the power of XDP (eBPF) and dive into the world of efficient load balancing with Katran. Discover how this innovative technology enables network packet redirection and seamless traffic distribution, all while maintaining session consistency.">
<meta name="keywords" content="">

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="eBPF journey by examples: L4 load balancing with XDP and Katran"/>
<meta name="twitter:description" content="Explore the power of XDP (eBPF) and dive into the world of efficient load balancing with Katran. Discover how this innovative technology enables network packet redirection and seamless traffic distribution, all while maintaining session consistency."/>

<meta property="og:title" content="eBPF journey by examples: L4 load balancing with XDP and Katran" />
<meta property="og:description" content="Explore the power of XDP (eBPF) and dive into the world of efficient load balancing with Katran. Discover how this innovative technology enables network packet redirection and seamless traffic distribution, all while maintaining session consistency." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://fedepaol.github.io/blog/2023/09/06/ebpf-journey-by-examples-l4-load-balancing-with-xdp-and-katran/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-06T15:01:51+01:00" />
<meta property="article:modified_time" content="2023-09-06T15:01:51+01:00" />




<link rel="canonical" href="https://fedepaol.github.io/blog/2023/09/06/ebpf-journey-by-examples-l4-load-balancing-with-xdp-and-katran/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.577e3c5ead537873430da16f0964b754a120fd87c4e2203a00686e7c75b51378.css" integrity="sha256-V348Xq1TeHNDDaFvCWS3VKEg/YfE4iA6AGhufHW1E3g=" crossorigin="anonymous" media="screen" />








 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>




<body class="preload-transitions colorscheme-light">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="https://fedepaol.github.io/">
      My little software warehouse
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts/">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="mailto:fedepaol@gmail.com">Contact</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://fedepaol.github.io/blog/2023/09/06/ebpf-journey-by-examples-l4-load-balancing-with-xdp-and-katran/">
              eBPF journey by examples: L4 load balancing with XDP and Katran
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2023-09-06T15:01:51&#43;01:00">
                September 6, 2023
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              9-minute read
            </span>
          </div>
          
          
          
        </div>
      </header>

      <div class="post-content">
        
        <h1 id="katran">
  Katran
  <a class="heading-link" href="#katran">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>This is my second post about digging into popular eBPF projects. You can see the first post about Falco and tracepoints <a href="https://fedepaol.github.io/blog/2023/08/21/ebpf-journey-by-examples-ebpf-tracepoints-with-falco/" >here</a>.</p>
<p>This time I am looking at <a href="https://github.com/facebookincubator/katran"  class="external-link" target="_blank" rel="noopener">katran</a>, an xdp based loadbalancer opensourced by Meta.</p>
<p>A loadbalancer works in a very simple way: it translates network packets directed towards a single virtual IP (VIP) toward a serie of endpoints (<code>real</code>s, in katran&rsquo;s lingo),
while maintaining session consistency (meaning, all the packets belonging to a given tcp session are sent to the same <code>real</code>).</p>
<p>Katran&rsquo;s loadbalancing is peculiar in the sense that:</p>
<ul>
<li>it assumes all the <code>reals</code> are reacheable via a single next hop katran is configured with, which is expected to do the routing logic</li>
<li>works in DSR mode (direct server return), meaning the reply is not getting back through the load balancer but will come directly from the server</li>
<li>each <code>real</code> has the VIP associated to a loopback interface. This allows the <code>real</code> to reply to packets directed to the VIP</li>
<li>the packet directed to the VIP is encapsulated via IPIP inside a packet directed to the <code>real</code> (this allows the <code>real</code>s to be on different subnets)</li>
</ul>
<p>The flow looks like:</p>
<pre tabindex="0"><code class="language-none" data-lang="none">                                        ┌───────┬───────┬┬──────┬───┬─────┬─┐
                                        │Katran │Real IP││Client│VIP│Data │ │
                                        │  IP   │       ├┴──────┴───┴─────┘ │
                                        │       │       │                   │
              ┌──────┬───┬─────┐        └───────┴───────┴───────────────────┘
              │Client│VIP│Data │
┌───────────┐ └──────┴───┴─────┘  ┌───────────┐                  ┌───────────┐
│           │                     │           │                  │           │
│  Client   ├────────────────────►│  Katran   ├─────────────────►│  Real     │
│           │                     │           │                  │           │
└───────────┘                     └───────────┘                  └────┬──────┘
    ▲                                                                 │
    │                                                                 │
    │                                                                 │
    │                                                                 │
    │                                                                 │
    └─────────────────────────────────────────────────────────────────┘

                            ┌───┬──────┬─────┐
                            │VIP│Client│Data │
                            └───┴──────┴─────┘
</code></pre><p>Where each packet is represented by src, dst and payload.</p>
<h2 id="xdp">
  XDP
  <a class="heading-link" href="#xdp">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>XDP not only allows to intercept incoming packets, but also to do more fancier things such as modifying those packets
and sending back, either via the same interface or another.</p>
<p>By leveraging XDP, katran is able to:</p>
<ul>
<li>intercept incoming packets directed to the VIP</li>
<li>calculate the IP of the <code>real</code> related to that session</li>
<li>transform the packet to a packet directed to the <code>real</code> IP (even by changing the ip family)</li>
<li>encapsulate the packet and send it back to the interface it came from</li>
</ul>
<h2 id="looking-at-the-code">
  Looking at the code
  <a class="heading-link" href="#looking-at-the-code">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>The <code>balancer_ingress</code> XDP program is the <a href="https://github.com/facebookincubator/katran/blob/7cca2aae1607ab6770d80b08ec640b7f9dc5106f/katran/lib/bpf/balancer_kern.c#L934"  class="external-link" target="_blank" rel="noopener">entry point</a> for the balancing logic, which is then deferred to the <code>process_packet</code> function.</p>
<p>Leaving corner cases aside, what <code>process_packet</code> does is:</p>
<h3 id="finding-the-dst-address-corresponding-to-the-packet-directed-to-the-vip">
  Finding the dst address corresponding to the packet directed to the <code>vip</code>
  <a class="heading-link" href="#finding-the-dst-address-corresponding-to-the-packet-directed-to-the-vip">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dst</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">pckt</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">F_SYN_SET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="o">!</span><span class="p">(</span><span class="n">vip_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">F_LRU_BYPASS</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">connection_table_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pckt</span><span class="p">,</span> <span class="n">lru_map</span><span class="p">,</span> <span class="cm">/*isGlobalLru=*/</span><span class="nb">false</span><span class="p">);</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dst</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">pckt</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">F_SYN_SET</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">vip_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">F_GLOBAL_LRU</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kt">int</span> <span class="n">global_lru_lookup_result</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="nf">perform_global_lru_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pckt</span><span class="p">,</span> <span class="n">cpu_num</span><span class="p">,</span> <span class="n">vip_info</span><span class="p">,</span> <span class="n">is_ipv6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">global_lru_lookup_result</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">global_lru_lookup_result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// if dst is not found, route via consistent-hashing of the flow.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dst</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* ... stats handling ... */</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">get_packet_dst</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pckt</span><span class="p">,</span> <span class="n">vip_info</span><span class="p">,</span> <span class="n">is_ipv6</span><span class="p">,</span> <span class="n">lru_map</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">XDP_DROP</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="cm">/* ... stats handling ... */</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><ul>
<li>if the packet is a SYN packet, the session is a new one and thus it does not make sense to look into the LRU cache</li>
<li>if the packet is not a SYN packet, katran performs a lookup into a per-cpu lru cache (1), then into a global LRU cache (2)</li>
<li>if the <code>real</code> IP is not found, then a hashing function is performed and the dst is calculated (3)</li>
</ul>
<p>One interesting thing to notice is the set of properties related to the vip (<code>vip_info-&gt;flags</code>), which allow to skip the caches
for example (the rationale behind this is to avoid filling up the memory).</p>
<h3 id="load-balancing-getting-the-packet-destination">
  Load balancing (getting the packet destination)
  <a class="heading-link" href="#load-balancing-getting-the-packet-destination">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>The computation performed by <code>get_packet_dst</code> is stateless and depends on the packet. The gist of the way it (more or less) works is:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">    <span class="n">hash</span> <span class="o">=</span> <span class="nf">get_packet_hash</span><span class="p">(</span><span class="n">pckt</span><span class="p">,</span> <span class="n">hash_16bytes</span><span class="p">)</span> <span class="o">%</span> <span class="n">RING_SIZE</span><span class="p">;</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">key</span> <span class="o">=</span> <span class="n">RING_SIZE</span> <span class="o">*</span> <span class="p">(</span><span class="n">vip_info</span><span class="o">-&gt;</span><span class="n">vip_num</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">;</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">real_pos</span> <span class="o">=</span> <span class="nf">bpf_map_lookup_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch_rings</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span> <span class="c1">// 3 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">real_pos</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">key</span> <span class="o">=</span> <span class="o">*</span><span class="n">real_pos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">pckt</span><span class="o">-&gt;</span><span class="n">real_index</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">real</span> <span class="o">=</span> <span class="nf">bpf_map_lookup_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reals</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span> <span class="c1">// 4
</span></span></span></code></pre></div><ul>
<li>the hash of the packet is calculated and modulized RING_SIZE</li>
<li>the key is RING_SIZE (an array containing all the <code>real</code> indexes for all the vips, ordered in chunks). The i-th VIP chunk is between
<code>RING_SIZE * (vip_info-&gt;vip_num)`` and </code>RING_SIZE * (vip_info-&gt;vip_num) + RING_SIZE`. My guess is, this allows to have a non even distributions
of reals (3)</li>
<li>the real is finally fetched (4)</li>
</ul>
<h3 id="encapsulating-and-redirecting-the-packet">
  Encapsulating and redirecting the packet
  <a class="heading-link" href="#encapsulating-and-redirecting-the-packet">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>Once the dst is found, the redirection takes place:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">  <span class="n">cval</span> <span class="o">=</span> <span class="nf">bpf_map_lookup_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctl_array</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mac_addr_pos</span><span class="p">);</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cval</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">XDP_DROP</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* ... stats .. */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">F_IPV6</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">PCKT_ENCAP_V6</span><span class="p">(</span><span class="n">xdp</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span> <span class="n">is_ipv6</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pckt</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">pkt_bytes</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">XDP_DROP</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">PCKT_ENCAP_V4</span><span class="p">(</span><span class="n">xdp</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pckt</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">pkt_bytes</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="n">XDP_DROP</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">XDP_TX</span><span class="p">;</span> <span class="c1">// 3
</span></span></span></code></pre></div><ul>
<li>The details of the next hop are fetched (1)</li>
<li>The new (encapsulated) packet is generated, with the <code>real</code> ip as dst, a crafted src ip and the original packet as payload (2)</li>
<li>The XDP_TX verdict is returned, meaning that the packet is not passed to the kernel stack but sent out back to the same interface it was received (3)</li>
</ul>
<p>I won&rsquo;t expand too much the details of the encapsulation, that can be found <a href="https://github.com/facebookincubator/katran/blob/1f464b97d47750ce0195cf5b7789d7524d8a1110/katran/lib/bpf/pckt_encap.h#L95"  class="external-link" target="_blank" rel="noopener">here</a>, as they involve manipulating the headers, setting the right payload, src and dst and recalculating the checksum.</p>
<p>It&rsquo;s interesting to notice that the encapsulation depends on the ip family of the <code>real</code>, and might belong to a different IP family than the VIP.
Also, the tos flags are preserved.</p>
<h2 id="a-hidden-gem">
  A hidden gem
  <a class="heading-link" href="#a-hidden-gem">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>While looking for all the eBPF programs in the repo, I found <a href="https://github.com/facebookincubator/katran/blob/6cb4f69303a705a1a3b54bc2776611a85ae3099f/katran/tpr/bpf/tcp_pkt_router_kern.c#L109"  class="external-link" target="_blank" rel="noopener">this sockops program</a>. After digging a bit, my understanding is that it allows the server to send the serverid to the client directly into the tcp header options
(in the syn/ack message):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">BPF_SOCK_OPS_WRITE_HDR_OPT_CB</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* Write the server-id as hdr-opt */</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">((</span><span class="n">skops</span><span class="o">-&gt;</span><span class="n">skb_tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCPHDR_SYNACK</span><span class="p">)</span> <span class="o">==</span> <span class="n">TCPHDR_SYNACK</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">handle_passive_write_hdr_opt</span><span class="p">(</span><span class="n">skops</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="n">s_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*...*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">hdr_opt</span><span class="p">.</span><span class="n">kind</span> <span class="o">=</span> <span class="n">TCP_HDR_OPT_KIND</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">hdr_opt</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">TCP_HDR_OPT_LEN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">hdr_opt</span><span class="p">.</span><span class="n">server_id</span> <span class="o">=</span> <span class="n">s_info</span><span class="o">-&gt;</span><span class="n">server_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">err</span> <span class="o">=</span> <span class="nf">bpf_store_hdr_opt</span><span class="p">(</span><span class="n">skops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr_opt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hdr_opt</span><span class="p">),</span> <span class="n">NO_FLAGS</span><span class="p">);</span>
</span></span></code></pre></div><p>On the client side on the other hand, parses the serverid coming from the syn/ack message :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">      <span class="cm">/* Read hdr-opt sent by the passive side
</span></span></span><span class="line"><span class="cl"><span class="cm">       * Only parse the SYNACK because server TPR only sends OPT with SYNACK */</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">((</span><span class="n">skops</span><span class="o">-&gt;</span><span class="n">skb_tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCPHDR_SYNACK</span><span class="p">)</span> <span class="o">==</span> <span class="n">TCPHDR_SYNACK</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">handle_active_parse_hdr</span><span class="p">(</span><span class="n">skops</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span></code></pre></div><p>To set it back in sequent messages:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">BPF_SOCK_OPS_WRITE_HDR_OPT_CB</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* Echo back the server-id as hdr-opt
</span></span></span><span class="line"><span class="cl"><span class="cm">       * Don&#39;t attempt to do this for the SYN packet because we only
</span></span></span><span class="line"><span class="cl"><span class="cm">       * get the OPT in the SYNACK */</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">((</span><span class="n">skops</span><span class="o">-&gt;</span><span class="n">skb_tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCPHDR_SYN</span><span class="p">)</span> <span class="o">!=</span> <span class="n">TCPHDR_SYN</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">handle_active_write_hdr_opt</span><span class="p">(</span><span class="n">skops</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span></code></pre></div><p>This trick allows the XDP program to avoid even accessing the LRU maps / calculating the id of the <code>real</code>, because the id
is already contained in the tcp header, in the <a href="https://github.com/facebookincubator/katran/blob/7cca2aae1607ab6770d80b08ec640b7f9dc5106f/katran/lib/bpf/balancer_kern.c#L744"  class="external-link" target="_blank" rel="noopener">following part</a> of the <code>process_packet</code> function I omitted commenting:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dst</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef TCP_SERVER_ID_ROUTING
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="c1">// First try to lookup dst in the tcp_hdr_opt (if enabled)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">pckt</span><span class="p">.</span><span class="n">flow</span><span class="p">.</span><span class="n">proto</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">pckt</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">F_SYN_SET</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">__u32</span> <span class="n">routing_stats_key</span> <span class="o">=</span> <span class="n">MAX_VIPS</span> <span class="o">+</span> <span class="n">TCP_SERVER_ID_ROUTE_STATS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">struct</span> <span class="n">lb_stats</span><span class="o">*</span> <span class="n">routing_stats</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="nf">bpf_map_lookup_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">routing_stats_key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">routing_stats</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">XDP_DROP</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nf">tcp_hdr_opt_lookup</span><span class="p">(</span><span class="n">xdp</span><span class="p">,</span> <span class="n">is_ipv6</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pckt</span><span class="p">)</span> <span class="o">==</span> <span class="n">FURTHER_PROCESSING</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">routing_stats</span><span class="o">-&gt;</span><span class="n">v1</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// update this routing decision in the lru_map as well
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">lru_map</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">vip_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">F_LRU_BYPASS</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nf">check_and_update_real_index_in_lru</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="o">&amp;</span><span class="n">pckt</span><span class="p">,</span> <span class="n">lru_map</span><span class="p">,</span> <span class="cm">/* update_lru */</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">routing_stats</span><span class="o">-&gt;</span><span class="n">v2</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">// TCP_SERVER_ID_ROUTING
</span></span></span></code></pre></div><h2 id="poor-mans-version">
  Poor man&rsquo;s version
  <a class="heading-link" href="#poor-mans-version">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>Here I will try to mimic the very minimum of what Katran implements, avaliable at the <a href="https://github.com/fedepaol/ebpfexamples/tree/main/xdpkatransample"  class="external-link" target="_blank" rel="noopener">following link</a>.</p>
<p>Instead of calculating the endpoint that corresponds to the VIP, my program just discard any packet that is not directed
to the VIP, and translates it to a fixed <code>real</code> IP.</p>
<p>Both the <code>real</code> IP and the VIP are passed to the program via a BPF_MAP_TYPE_ARRAY to the program. Additionally, the
MAC address of the next hop is passed to the program.</p>
<p>The program does the filtering of non IPV4 packets, and non TCP packets, and then leverages
the encapsulation logic <strong>stolen</strong> inspired from Katran.</p>
<p>It reads the arguments from the map provided by the Go side and then prepares
the encapsulated packet to be sent back to the interface:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">arguments</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">__u32</span> <span class="n">key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">arguments</span> <span class="o">*</span><span class="p">)</span><span class="nf">bpf_map_lookup_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xdp_params_array</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">bpf_printk</span><span class="p">(</span><span class="s">&#34;no args&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">XDP_PASS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">bpf_xdp_adjust_head</span><span class="p">(</span><span class="n">xdp</span><span class="p">,</span> <span class="mi">0</span> <span class="o">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="p">)))</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">memcpy</span><span class="p">(</span><span class="n">new_eth</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">,</span> <span class="n">dst_mac</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span> <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">old_eth</span><span class="o">-&gt;</span><span class="n">h_dest</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">&gt;</span> <span class="n">data_end</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">memcpy</span><span class="p">(</span><span class="n">new_eth</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">,</span> <span class="n">old_eth</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span> <span class="c1">// 4 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">new_eth</span><span class="o">-&gt;</span><span class="n">h_proto</span> <span class="o">=</span> <span class="n">BE_ETH_P_IP</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">create_v4_hdr</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">iph</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">saddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">daddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">pkt_bytes</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">IPPROTO_IPIP</span><span class="p">);</span> <span class="c1">// 5
</span></span></span></code></pre></div><p>This simplified version:</p>
<ul>
<li>Reads the arguments passed from user space (1)</li>
<li>Makes room for the header of the IPIP tunnel (2)</li>
<li>Sets the source mac address using the original destination one, the one of the interface (3)</li>
<li>Sets the destination mac address as the one provided by the parameters (the gateway one) (4)</li>
<li>Creates the IPIP header using the destination of the real as the destination IP (5)</li>
</ul>
<h3 id="testing-it-for-real">
  Testing it (for real)
  <a class="heading-link" href="#testing-it-for-real">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>The <a href="https://github.com/fedepaol/ebpfexamples/tree/main/xdpkatransample/repro"  class="external-link" target="_blank" rel="noopener">repro subfolder</a> contains the setup I used
to validate my ramblings were correct.</p>
<p>I used a container-based environment using <code>docker-compose</code> (I know, it&rsquo;s not a-la-mode anymore) with multiple
networks, setting the right routes in the various containers.</p>
<p>The containers layout look a bit like:</p>
<pre tabindex="0"><code class="language-raw" data-lang="raw">              10.111.220.0/24                 10.111.222.0/24

┌──────────────────┐       ┌───────────────────┐        ┌───────────────────┐
│                  │       │                   │        │                   │
│                  │ ◄─────┼───────────────────┼────────┤                   │
│                  │       │                   │        │                   │
│    Client        ├──────►│  Gateway          │        │    Real           │
│                  │       │             ┌─────┼───────►│                   │
│                  │       │             │     │        │                   │
│                  │       │             │     │        │                   │
└──────────────────┘       └──────┬──────┴─────┘        └───────────────────┘
                                  │      ▲
                                  │      │
                                  │      │  10.111.221.0/24
                                  ▼      │
                            ┌────────────┴─────┐
                            │                  │
                            │                  │
                            │                  │
                            │     Katran       │
                            │                  │
                            │                  │
                            └──────────────────┘
</code></pre><p>There are three different network segments:</p>
<ul>
<li>client - gateway</li>
<li>katran - gateway</li>
<li>client - real</li>
</ul>
<p>To make things work, the <code>VIP</code> must be assigned to the loopback interface of the <code>real</code>, and an <code>IPIP</code> interface must be created:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ip addr add 192.168.10.1 dev lo                                                                              
</span></span><span class="line"><span class="cl">ip link add name ipip0 <span class="nb">type</span> ipip external                                       
</span></span><span class="line"><span class="cl">ip link <span class="nb">set</span> up dev ipip0                                                        
</span></span></code></pre></div><p>All the setup files can be found in the <a href="https://github.com/fedepaol/ebpfexamples/tree/main/xdpkatransample/repro/setup"  class="external-link" target="_blank" rel="noopener">github repo</a>.</p>
<p>Another thing to note is that the RP_FILTER parameter must be disabled on the local machine (running
<code>echo 0 &gt; /proc/sys/net/ipv4/conf/all/rp_filter</code> should make the trick).</p>
<h3 id="profit">
  Profit!
  <a class="heading-link" href="#profit">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>It works, but it took me a bit. This is the reason why this second post took so long to be published.</p>
<p>I wrote the program, prepared the setup, looked for the packets and&hellip; nothing. This dragged me in a rabbit hole from which I managed to come back, but since this post is already quite long I will skip this part and write about it in a new post.</p>
<h2 id="wrapping-up">
  Wrapping Up
  <a class="heading-link" href="#wrapping-up">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>XDP is very powerful (but also very low level!). It allow us to access to the raw bytes of the ethernet frame, and
mess up with them in a very efficient way.</p>
<p>Here I showed how Katran leverages XDP to do L4 load balancing, and how the very same setup can be replicated.
As always, my considerations here are based on my understanding of the documentation and the code. If something
is not accurate please reach out!</p>

      </div>


      <footer>
        


        <div id="disqus_thread"></div>
<script>
  window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "fedepaolgithubio" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    
    document.addEventListener('themeChanged', function (e) { 
        if (document.readyState == 'complete') {
          DISQUS.reset({ reload: true, config: disqus_config });
        }
    });
</script>
        
        
        
        

        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
    2024
     Federico Paolinelli 
    ·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  
<script>
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-16514009-2', 'auto');
	
	ga('send', 'pageview');
}
</script>

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>
